# -*- coding: utf-8 -*-

# Mathmaker creates automatically maths exercises sheets
# with their answers
# Copyright 2006-2015 Nicolas Hainaux <nico_h@users.sourceforge.net>

# This file is part of Mathmaker.

# Mathmaker is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# any later version.

# Mathmaker is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Mathmaker; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import math
import sys

from lib.common import latex
from lib.common.cfg import CONFIG
from lib.common import software
from lib.common.cst import *

from core.base import *
from core.base_calculus import *
from lib import *
import core.base_calculus

from . import Structure


# ------------------------------------------------------------------------------
# --------------------------------------------------------------------------
# ------------------------------------------------------------------------------
##
# @class LaTeX
# @brief This machine knows how to write LaTeX commands & math expressions
# @todo When creating another machine, some things might have to change here
class LaTeX(Structure.Structure):





    # --------------------------------------------------------------------------
    ##
    #   @brief Constructor
    #   The created machine is set to the beginning of an expression,
    #   its language is the default one (from cfg file or in case of any
    #   problem, from text.DEFAULT_LANGUAGE)
    #   its encoding is set to the default one (from cfg file or in case of any
    #   problem, from latex.DEFAULT_ENCODING)
    #   @param expression_begins True if machine's at an expression's beginning
    #   @param **options Any options
    #   @return One instance of machine.LaTeX
    #   @todo The warning handling should be done in the main program
    def __init__(self, language, **options):

        self.text_sizes = latex.TEXT_SIZES

        self.font_size_offset = 0

        self.create_pic_files = True

        if 'create_pic_files' in options \
            and not options['create_pic_files'] in YES:
        #___
            self.create_pic_files = False

        # Encoding...
        self.encoding = latex.DEFAULT_ENCODING
        try:
            encoding_cfg = CONFIG[latex.FORMAT]["ENCODING"]
        except error.UnreachableData:
            pass
        else:
            self.encoding = encoding_cfg

        # Language...
        self.language = ""


        if not language in latex.LANGUAGE_PACKAGE_NAME:
            error.write_warning(_("the LaTeX language package matching the \
chosen language ({language_ref}) is not implemented yet in {software_ref}, \
which will try to use the language entry from the configuration file instead")\
.format(software_ref=software.NAME,
        language_ref=language))
            if not default.LANGUAGE in latex.LANGUAGE_PACKAGE_NAME:
                error.write_warning(_("the LaTeX language package matching \
the language entry from the configuration file is neither implemented in \
{software_ref}, which will use the english package instead")\
.format(software_ref=software.NAME))
                self.language = latex.ENGLISH
            else:
                self.language = latex.LANGUAGE_PACKAGE_NAME[default.LANGUAGE]

            self.language_code = latex.LANGUAGE_CODE_NAMES[self.language]

        else:
            self.language = latex.LANGUAGE_PACKAGE_NAME[language]
            self.language_code = language


        self.markup = latex.MARKUP

        self.out = sys.stdout

        if 'out' in options:
            self.out = options['out']

        self.redirect_output_to_str = False







    # --------------------------------------------------------------------------
    ##
    #   @brief Write the complete LaTeX header of the sheet to the output.
    def write_document_header(self):
        result = ""

        result += "% " + _( \
              "{document_format} document generated by {software_ref}")\
              .format(document_format=latex.FORMAT_NAME_PRINT,
                      software_ref=software.NAME_PRINTABLE + " " \
                                + software.VERSION) + "\n"
        result += "% " + _("{software_ref} is free software. Its license \
is {software_license}.").format(software_ref=software.NAME_PRINTABLE,
                                software_license=software.LICENSE) + "\n"
        result += "% " + _("Further details on {software_website}")\
                       .format(software_website=software.WEBSITE) + "\n"
        result += "% " + software.COPYRIGHT + " " + software.AUTHOR +"\n"

        result += "\documentclass[a4paper,fleqn,12pt]{article}" + "\n"
        if self.encoding == latex.UCS_UTF8X:
            result += r"\usepackage{ucs}" + "\n"
            result += r"\usepackage[" + latex.UTF8X + "]{inputenc}" \
                           + "\n"
        else:
            result += r"\usepackage[" + self.encoding + "]{inputenc}" \
                           + "\n"

        result += r"\usepackage[" \
                       + self.language \
                       + "]{babel}" + "\n"

        result += r"\usepackage[T1]{fontenc}" + "\n"
        result += "% " + _("To solve accent problems: ") + "\n"
        result += r"%\usepackage{lmodern}" + "\n"
        result += "% " + _("Using lmodern package might be better than \
cm aeguill") + "\n"
        result += r"\usepackage[cm]{aeguill}" + "\n"
        result += "% " + _("To strike out numbers ") + "\n"
        result += r"\usepackage{cancel}" + "\n"
        result += "% " + _("To use the margin definition command") + "\n"
        result += r"\usepackage{geometry}" + "\n"
        result += "% " + _("To use the commands from {pkg_name} ")\
                         .format(pkg_name="theorem") + "\n"
        result += r"%\usepackage{theorem}" + "\n"
        result += "% " + _("To use multicol environment") + "\n"
        result += r"\usepackage{multicol}" + "\n"
        result += "% " + _("To use extra commands to handle tabulars") + "\n"
        result += r"\usepackage{array}" + "\n"
        result += "% " + _("For pretty underlining") + "\n"
        result += r"\usepackage{ulem}" + "\n"
        result += "% " + _("To include .eps pictures") + "\n"
        result += r"\usepackage{graphicx}" + "\n"
        result += "% " + _("To use other mathematical symbols") + "\n"
        result += r"\usepackage{amssymb}" + "\n"
        result += r"\usepackage{amsmath}" + "\n"
        result += "% " + _("To use the euro symbol") + "\n"
        result += r"\usepackage{eurosym}" + "\n"
        result += "% " + _("To draw") + "\n"
        result += r"\usepackage{tikz}" + "\n"
        result += "% " + _("Page layout ") + "\n"
        result += "\geometry{hmargin=1.5cm, vmargin=1.5cm}" + "\n"
        result += "\setlength{\parindent}{0cm}" + "\n"
        result += "\pagestyle{empty}" + "\n"
        result += " " + "\n"
        result += r"\usepackage{epstopdf}" + "\n"
        result += "%%% " + _("If you wish to include a picture, \
please use this command:") + "\n"
        result += "%%% \includegraphics[height=6cm]{"
        result += _("file_name")
        result += ".eps} \n"
        result += " " + "\n"
        result += "% " + _("Exercises counter") + "\n"
        result += "\\newcounter{n}" + "\n"
        result += "% " + _("Definition of the {cmd_name} command, \
which will insert the word {word} in bold, with its number and \
automatically increments the counter").format(cmd_name="exercise",
                                              word=_("Exercise")) + "\n"
        result += "\\newcommand{\exercise}{\\noindent \hspace{-.25cm}" \
              + " \stepcounter{n} " + self.translate_font_size('Large') \
              + " \\textbf{" \
              + _("Exercise") \
              + " \\arabic{n}} " \
              + "\\newline " + self.translate_font_size('large') + " }" + " \n"
        result += "% " + _("Definition of the command resetting the \
exercises counter (which is useful when begining to write the answers sheet)")\
+ "\n"
        result += "\\newcommand{\\razcompteur}{\setcounter{n}{0}}" + "\n"
        result += " " + "\n"
        result += r"\usetikzlibrary{calc}" + "\n"
        result += r"\epstopdfsetup{outdir=./}" + "\n"

        if self.redirect_output_to_str:
            return result

        else:
            self.out.write(result)





    # --------------------------------------------------------------------------
    ##
    #   @brief Writes to the output the command to begin the document
    def write_document_begins(self):
        output_str = "\\begin{document}" + "\n"
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Writes to the output the end of document command
    def write_document_ends(self):
        output_str = "\end{document} " + "\n"
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Writes to the output the command displaying an exercise's title
    def write_exercise_number(self):
        output_str = "\exercise" + "\n"
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Writes to the output the jump to next page command
    def write_jump_to_next_page(self):
        output_str = "\\newpage" + "\n"
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Writes to the output the exercises counter reinitialize command
    def reset_exercises_counter(self):
        output_str = "\\razcompteur " + "\n"
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Writes to the output the new line command
    def write_new_line(self, **options):
        output_str = "\\newline " + "\n"
        if 'check' in options:
            if options['check'] == '\]':
                output_str = ""
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Writes to the output two commands writing two new lines
    def write_new_line_twice(self, **options):
        output_str = "\\newline " + "\n" + " \\newline " + "\n"
        if 'check' in options:
            if options['check'] == '\]':
                output_str = ""
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Prints the given string as a mathematical expression
    def write_math_style2(self, given_string):
        output_str = self.markup['opening_math_style2'] + " " \
              + given_string \
              + " " + self.markup['closing_math_style2']

        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Prints the given string as a mathematical expression
    def write_math_style1(self, given_string):
        output_str = self.markup['opening_math_style1'] + " " \
              + given_string \
              + " " + self.markup['closing_math_style1']

        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)

    ##
    #   @brief Writes to the output the given string
    #   @option emphasize='bold'|'italics'|'underlined'
    def write(self, given_string, **options):
        output_str = ""

        if 'emphasize' in options:
            if options['emphasize'] == 'bold':
                output_str = "\\textbf{"  + given_string + "}" + "\n"
            elif options['emphasize'] == 'italics':
                output_str = "\\textit{" + given_string + "}" + "\n"
            elif options['emphasize'] == 'underlined':
                output_str = r"\uline{" + given_string + "}" + "\n"
            else:
                output_str = given_string
        else:
            output_str = given_string

        if 'multicolumns' in options:
            if type(options['multicolumns']) == int \
                and options['multicolumns'] >= 1:
            #___
                output_str = "\\begin{multicols}{" \
                             + str(options['multicolumns']) + "} " + "\n" \
                             + output_str \
                             + "\end{multicols}" + "\n"
            else:
                raise error.OutOfRangeArgument(options['multicolumns'],
                                               ' should be an int >=1\n')

        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)


    ##
    #   @brief turn the size keyword in LaTeX matching keyword
    #   @warning if you chose a too low or too high value as font_size_offset,
    #   @warning then all the text will be either tiny or Huge.
    def translate_font_size(self, arg):
        if not type(arg) == str:
            raise error.UncompatibleType(objct, "String")
        elif not arg in TEXT_SCALES:
            raise error.UncompatibleType(objct, "a text size" \
                                                + " (see TEXT_SCALES)")

        arg_num = TEXT_RANKS[arg]

        size_to_use = self.font_size_offset + arg_num

        if size_to_use < 0:
            size_to_use = 0
        elif size_to_use > len(self.text_sizes) - 1:
            size_to_use = len(self.text_sizes) - 1

        return self.text_sizes[size_to_use]


    ##
    #   @brief Writes to the output the command setting the text size
    def write_set_font_size_to(self, arg):
        output_str = self.translate_font_size(arg) + "\n"
        if self.redirect_output_to_str:
            return output_str
        else:
            self.out.write(output_str)




    ##
    #   @brief Writes a table filled with the given [strings]
    #   @param size: (nb of lines, nb of columns)
    #   @param col_widths: [int]
    #   @param content: [strings]
    #   @options: borders='all'
    #   @options: unit='inch' etc. (check the possibilities...)
#    def write_table(self, size, col_widths, content, **options):
#        n_col = size[1]
#        n_lin = size[0]
#        result = ""

#        length_unit = 'cm'
#        if 'unit' in options:
 #           length_unit = options['unit']
#
 #       tabular_format = ""
 #       v_border = ""
 #       h_border = ""
 ##       center = ""
 #       new_line_sep = "\\\\" + "\n"
#
 #       if 'center' in options:
  #          center = ">{\centering}"
  #          new_line_sep = "\\tabularnewline" + "\n"
#
   #     if 'borders' in options and options['borders'] == 'all':
  #          v_border = "|"
   #         h_border = "\\hline \n"

  #      for i in xrange(len(col_widths)):
   #         tabular_format += v_border \
   #                           + center \
    #                          + "p{" + str(col_widths[i]) + " " \
    #                          + str(length_unit) + "}"
#
   #     tabular_format += v_border

    #    result += "\\begin{tabular}{"+ tabular_format + "}" + "\n"
    #    result += h_border

  #    #  for i in xrange(n_lin):
  #          for j in xrange(n_col):
   #             result += str(content[i*n_col + j])
   #             if j != n_col - 1:
    #                result += "&" + "\n"
    #        if i != n_lin - 1:
    #            result += new_line_sep + h_border

    #    result += new_line_sep + h_border
    #    result += "\end{tabular} " + "\n"

     #   if self.redirect_output_to_str:
     #       return result
      #  else:
      #      self.out.write(result)


    ##
    #   @brief Writes content arranged like in a table.
    #   @brief In the case of latex, it will just be the same.
    #   @param size: (nb of lines, nb of columns)
    #   @param col_widths: [int]
    #   @param content: [strings]
    #   @options: borders=0|1|2|3... (not implemented yet)
    #   @options: unit='inch' etc. (check the possibilities...)
    def write_layout(self, size, col_widths, content, **options):
        if self.redirect_output_to_str:
            return translator.create_table(size,
                                           content,
                                           col_fmt=col_widths,
                                           **options)
        else:
            self.out.write(translator.create_table(size,
                                                   content,
                                                   col_fmt=col_widths,
                                                   **options))





    # --------------------------------------------------------------------------
    ##
    #   @brief Creates a LaTeX string of the given object
    def type_string(self, objct, **options):
        if isinstance(objct, Printable):
            core.base_calculus.expression_begins = True
            return objct.into_str(**options)
        elif is_.a_number(objct) or is_.a_string(objct):
            return str(objct)
        else:
            raise error.UncompatibleType(objct, "String|Number|Printable")





    # --------------------------------------------------------------------------
    ##
    #   @brief Draws a horizontal dashed line
    def insert_dashed_hline(self, **options):
        return "\\begin{tikzpicture}[x=2cm]" \
               + "\draw[black,line width=0.5pt,dashed] (0,0)--(9,0);" \
               + "\end{tikzpicture}" + "\n"





    # --------------------------------------------------------------------------
    ##
    #   @brief Puts a vertical space (default 1 cm)
    def insert_vspace(self, **options):
        return "\\vspace{1 cm}"





    # --------------------------------------------------------------------------
    ##
    #   @brief Returns a non-breaking space
    def insert_nonbreaking_space(self, **options):
        return "~"




    # --------------------------------------------------------------------------
    ##
    #   @brief Draws and inserts the picture of the drawable_arg
    def insert_picture(self, drawable_arg, **options):
        if not isinstance(drawable_arg, Drawable):
            raise error.WrongArgument(str(drawable_arg), 'a Drawable')

        if self.create_pic_files:
            drawable_arg.into_pic(**options)
        else:
            drawable_arg.into_pic(create_pic_files='no', **options)

        s = "1"
        if 'scale' in options:
            s = str(options['scale'])

        if 'vertical_alignment_in_a_tabular' in options:
            return "\\raisebox{-.5\height}{" \
                   + "\includegraphics[scale=" + s + "]{" \
                   + drawable_arg.eps_filename \
                   + "}" + "}"
        else:
            return "\includegraphics[scale=" + s + "]{" \
                    + drawable_arg.eps_filename \
                    + "}" + "\\newline" + "\n"





    # --------------------------------------------------------------------------
    ##
    #   @brief Sets the font_size_offset field
    def set_font_size_offset(self, arg):
        if not is_.an_integer(arg):
            raise error.UncompatibleType(arg, "Integer")

        else:
            self.font_size_offset = arg


    # --------------------------------------------------------------------------
    ##
    #   @brief Sets the redirect_output_to_str field to True or False
    def set_redirect_output_to_str(self, arg):
        if type(arg) == bool:
            self.redirect_output_to_str = arg
        else:
            raise error.OutOfRangeArgument(arg, " boolean ")
