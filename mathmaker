#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright 2006-2015 Nicolas Hainaux <nico_h@users.sourceforge.net>

# This file is part of Mathmaker.

# Mathmaker is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# Mathmaker is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Mathmaker; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

#import time
#start_time = time.time()
import sys, os, subprocess
import gettext
import shlex
from optparse import OptionParser

from lib.common import settings
from lib.common import shared
from lib.common import default
from lib.common import software
from lib.common.cfg import CONFIG
from lib import error
import machine
import sheet

EUKTOEPS_ERR_MSG = "mathmaker requires euktoeps to produce pictures"
EUKTOEPS_VERSION_ERR_MSG = " but euktoeps did not return the correct version"\
                           " information"

def main():

    settings.init()

    pathname = os.path.dirname(sys.argv[0])
    localedir = os.path.abspath(pathname) + "/locale"

    settings.localedir = localedir + "/"

    parser = OptionParser(usage="usage: %prog [options] arg",
                          version=software.NAME + " " + software.VERSION \
                                  + "\nLicense: " + software.LICENSE \
                                  + "\n" + software.COPYRIGHT + " " \
                                  + software.AUTHOR)

    parser.add_option("-l", "--language",
                      action="store",
                      dest="lang",
                      default=default.LANGUAGE,
                      metavar="LANGUAGE",
                      help="force the language of the output to LANGUAGE." \
                           + " Default value is configured in " \
                           + software.NAME + "." + software.CFG_FILE_SUFFIX)

    (options, args) = parser.parse_args()

    path_to_euktoeps = CONFIG["PATHS"]["EUKTOEPS"]
    call_euktoeps = None

    try:
        call_euktoeps = subprocess.Popen([path_to_euktoeps, "-v"],
                                          stdout=subprocess.PIPE)
    except OSError:
        sys.stderr.write(EUKTOEPS_ERR_MSG \
                         + " but the path to euktoeps " \
                         + "written in mathmaker.cfg " \
                         + "doesn't seem to match anything.\n")
        sys.exit(2)

    check_euktoeps = shlex.split(subprocess.Popen(["grep", "version"],
                                                  stdin=call_euktoeps.stdout,
                                                  stdout=subprocess.PIPE)\
                                                      .communicate()[0].decode()
                                )

    if not len(check_euktoeps) == 3:
        sys.stderr.write(  EUKTOEPS_ERR_MSG \
                            + EUKTOEPS_VERSION_ERR_MSG \
                            + ".\n")
        sys.exit(2)

    if not check_euktoeps[0] == "Euktoeps":
        sys.stderr.write(  EUKTOEPS_ERR_MSG \
                         + EUKTOEPS_VERSION_ERR_MSG \
                         + " (name was not 'Euktoeps').\n")
        sys.exit(2)

    if not check_euktoeps[1] == "version":
        sys.stderr.write(  EUKTOEPS_ERR_MSG \
                         + EUKTOEPS_VERSION_ERR_MSG \
                         + " (the 'version' word was absent).\n")
        sys.exit(2)

    if not len(check_euktoeps[2]) == 5:
        sys.stderr.write(  EUKTOEPS_ERR_MSG \
                         + EUKTOEPS_VERSION_ERR_MSG \
                         + " (the version number seems incorrect).\n")
        sys.exit(2)

    if not check_euktoeps[2][0:3] == "1.5":
        sys.stderr.write(  EUKTOEPS_ERR_MSG \
                         + EUKTOEPS_VERSION_ERR_MSG \
                         + " (version number should begin with '1.5').\n")
        sys.exit(2)

    if not int(check_euktoeps[2][4]) >= 4:
        sys.stderr.write(  EUKTOEPS_ERR_MSG \
                         + EUKTOEPS_VERSION_ERR_MSG \
                         + " (version number should be at least 1.5.4).\n")
        sys.exit(2)

    settings.language = options.lang
    shared.init()

    try:
        gettext.translation(software.NAME,
                            localedir,
                            [options.lang]).install()
    except IOError as msg:
        error.write_warning("gettext returned the following message:\n" \
                            + str(msg) + "\n" \
                            + "It means the language indicated either \
in the command line or read from the configuration file isn't available yet \
in {software_ref} which will try to produce output in the language of your \
system.".format(software_ref=software.NAME) + "\n" )
        try:
            gettext.install(software.NAME,
                            localedir,
                            [locale.getdefaultlocale()[0]])
            settings.language = locale.getdefaultlocale()[0]
        except IOError as msg:
            error.write_warning("gettext returned the following message:\n" \
                            + str(msg) + "\n" \
                            + "It means the language of your system isn't \
available yet in {software_ref} which will produce output in \
english. If this results in producing an error, then your installation isn't \
complete.".format(software_ref=software.NAME) + "\n")
            gettext.translation(software.NAME,
                                localedir,
                                ['en']).install()
            settings.language = 'en'


    M = machine.LaTeX(options.lang)

    if len(args) >= 2:
        sys.stderr.write("Error: " + software.NAME \
                         + " does not require more than one argument.\n")
        sys.exit(2)

    elif len(args) == 1:
        if args[0] in sheet.AVAILABLE:
            sh = sheet.AVAILABLE[args[0]][0](M)

        elif args[0] in sheet.catalog.XML_SHEETS:
            sh = sheet.S_Generic(M, filename=sheet.catalog.XML_SHEETS[args[0]])

        elif os.path.isfile(args[0]):
            sh = sheet.S_Generic(M, filename=args[0])

        else:
            sys.stderr.write("Error: " + args[0] + " is not a correct argument "\
                             + "for " \
                             + software.NAME \
                             + ", you should use any item from the following " \
                             + " list:\n" \
                             + str(sorted([key for key in sheet.AVAILABLE]))\
                             + str(sorted([key for key in \
                                                    sheet.catalog.XML_SHEETS]))\
                             + "\n")

            #print("--- {sec} seconds ---"\
            #      .format(sec=round(time.time() - start_time, 3)))
            sys.exit(2)

    elif len(args) == 0:
        sys.stderr.write("Error: " + software.NAME \
                         + " requires one argument or" \
                         + " a valid filename.\n")

        sys.exit(2)

    M.write(str(sh))


if __name__ == '__main__':
    main()
    #print("--- {sec} seconds ---".format(sec=time.time() - start_time))
